# 增强逆向工程：为在反编译二进制文件中的漏洞分析研究和基准测试大型语言模型

发布时间：2024年11月07日

`LLM应用` `二进制代码`

> Enhancing Reverse Engineering: Investigating and Benchmarking Large Language Models for Vulnerability Analysis in Decompiled Binaries

# 摘要

> 安全专家对二进制代码进行逆向工程（反编译）以识别关键的安全漏洞。在关键系统（如固件、驱动程序和关键基础设施（CI）中使用的专有软件）中，对源代码的访问有限，这使得在二进制级别进行此分析更为关键。即使有可用的源代码，在编译后，源代码和处理器执行的二进制代码之间仍然存在语义差距。这种差距可能会阻碍对源代码中漏洞的检测。也就是说，当前对大型语言模型（LLM）的研究由于仅关注源代码而忽略了反编译二进制文件在这方面的重要性。在这项工作中，我们首次通过经验揭示了最先进的 LLM 在分析反编译二进制文件中的漏洞时存在的巨大语义限制，这在很大程度上是由于缺乏相关数据集。为了弥补这一差距，我们引入了 DeBinVul，这是一个新的反编译二进制代码漏洞数据集。我们的数据集是多架构和多优化的，由于 C/C++在 CI 中的广泛使用以及与众多漏洞的关联，我们重点关注 C/C++。具体来说，我们为（i）识别；（ii）分类；（iii）描述漏洞；以及（iv）恢复反编译二进制领域中的函数名称这一任务，整理了 150,872 个有漏洞和无漏洞的反编译二进制代码样本。随后，我们使用 DeBinVul 对最先进的 LLM 进行微调，并报告在检测二进制代码漏洞方面，CodeLlama、Llama3 和 CodeGen2 的能力分别提高了 19％、24％和 21％。此外，使用 DeBinVul，我们在漏洞分类任务上报告了 80-90％的高性能。此外，我们报告了在函数名称恢复和漏洞描述任务中的性能改进。

> Security experts reverse engineer (decompile) binary code to identify critical security vulnerabilities. The limited access to source code in vital systems - such as firmware, drivers, and proprietary software used in Critical Infrastructures (CI) - makes this analysis even more crucial on the binary level. Even with available source code, a semantic gap persists after compilation between the source and the binary code executed by the processor. This gap may hinder the detection of vulnerabilities in source code. That being said, current research on Large Language Models (LLMs) overlooks the significance of decompiled binaries in this area by focusing solely on source code. In this work, we are the first to empirically uncover the substantial semantic limitations of state-of-the-art LLMs when it comes to analyzing vulnerabilities in decompiled binaries, largely due to the absence of relevant datasets. To bridge the gap, we introduce DeBinVul, a novel decompiled binary code vulnerability dataset. Our dataset is multi-architecture and multi-optimization, focusing on C/C++ due to their wide usage in CI and association with numerous vulnerabilities. Specifically, we curate 150,872 samples of vulnerable and non-vulnerable decompiled binary code for the task of (i) identifying; (ii) classifying; (iii) describing vulnerabilities; and (iv) recovering function names in the domain of decompiled binaries. Subsequently, we fine-tune state-of-the-art LLMs using DeBinVul and report on a performance increase of 19%, 24%, and 21% in the capabilities of CodeLlama, Llama3, and CodeGen2 respectively, in detecting binary code vulnerabilities. Additionally, using DeBinVul, we report a high performance of 80-90% on the vulnerability classification task. Furthermore, we report improved performance in function name recovery and vulnerability description tasks.

[Arxiv](https://arxiv.org/abs/2411.04981)